# Scalable Commerce Core - Agent Instructions

## Project Overview

**Project Name**: scalable-commerce-core

**Description**: A modular e-commerce platform built with Node.js (Express), MySQL, and React (TypeScript), designed for shared hosting without Docker.

**Tech Stack**:
- **Backend**: Node.js with Express.js
- **Database**: MySQL
- **Frontend**: React with TypeScript
- **Hosting**: Shared hosting compatible (no Docker required)

**Key Features**:
- Quick user registration and authentication
- Complete shopping flow (browse, cart, checkout)
- Bulk product uploads (CSV/Excel import)
- Flexible discount management system
- Real-time order tracking
- Comprehensive admin panel
- Service-oriented, modular architecture
- Scalable and maintainable design

---

## Architecture & Design Principles

### Service-Oriented Architecture (SOA)

The platform is organized into distinct services that communicate through well-defined interfaces:

1. **Authentication Service**: User registration, login, JWT token management
2. **Product Service**: Product catalog, inventory management, search/filtering
3. **Cart Service**: Shopping cart operations, session management
4. **Order Service**: Order creation, management, tracking
5. **Discount Service**: Coupon and discount code management, validation
6. **Payment Service**: Payment processing integration
7. **Admin Service**: Dashboard, reporting, user management
8. **Import Service**: Bulk product uploads and data processing

### Modular Structure

Each service is self-contained with:
- Dedicated controllers for request handling
- Service layer for business logic
- Data access layer (models/repositories)
- Middleware for cross-cutting concerns
- Validation schemas (Joi, Yup, or similar)
- Error handling

### Database Design

- **Normalization**: 3NF to prevent data redundancy
- **Relationships**: Foreign keys for referential integrity
- **Indexing**: Strategic indexes on frequently queried columns
- **Shared Hosting**: SQL file backups, no complex stored procedures
- **Tables Structure**:
  - Users (id, email, password, name, created_at, updated_at)
  - Products (id, name, description, price, stock, category_id)
  - Categories (id, name, description)
  - Cart_Items (id, user_id, product_id, quantity)
  - Orders (id, user_id, total, status, created_at)
  - Order_Items (id, order_id, product_id, quantity, price)
  - Discounts (id, code, type, value, valid_from, valid_to)
  - Admin_Users (id, email, role, permissions)

---

## Coding Standards & Best Practices

### General Guidelines

1. **Code Organization**:
   - Use meaningful, descriptive variable and function names
   - Follow single responsibility principle
   - Avoid code duplication (DRY principle)
   - Keep functions small and focused

2. **Error Handling**:
   - Always wrap async operations in try-catch blocks
   - Return meaningful error messages to clients
   - Log errors with context (timestamp, user_id, action)
   - Use appropriate HTTP status codes (400, 401, 403, 404, 500)

3. **Validation**:
   - Validate all user inputs on the server side
   - Sanitize inputs to prevent SQL injection and XSS
   - Use middleware for cross-route validation
   - Define reusable validation schemas

4. **Security**:
   - Hash passwords using bcrypt
   - Use JWT for stateless authentication
   - Implement CORS properly
   - Validate and sanitize all external input
   - Use environment variables for sensitive data (.env file)
   - Implement rate limiting for API endpoints
   - Use HTTPS in production

### Backend (Node.js/Express)

```javascript
// 1. Controller Structure
class ProductController {
  async getProducts(req, res) {
    try {
      const products = await ProductService.getAll();
      res.json({ success: true, data: products });
    } catch (error) {
      res.status(500).json({ success: false, message: error.message });
    }
  }
}

// 2. Service Layer Pattern
class ProductService {
  static async getAll() {
    return await Product.find();
  }

  static async getById(id) {
    const product = await Product.findById(id);
    if (!product) throw new Error('Product not found');
    return product;
  }
}

// 3. Middleware Usage
app.use('/api', authenticate); // Apply auth to protected routes
app.use(errorHandler); // Global error handler

// 4. Route Organization
const productRoutes = express.Router();
productRoutes.get('/', ProductController.getProducts);
productRoutes.get('/:id', ProductController.getById);
app.use('/api/products', productRoutes);
```

### Frontend (React/TypeScript)

```typescript
// 1. Component Structure
interface Product {
  id: string;
  name: string;
  price: number;
  stock: number;
}

interface ProductListProps {
  onProductSelect: (product: Product) => void;
}

const ProductList: React.FC<ProductListProps> = ({ onProductSelect }) => {
  const [products, setProducts] = useState<Product[]>([]);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    fetchProducts();
  }, []);

  const fetchProducts = async () => {
    try {
      const response = await fetch('/api/products');
      setProducts(await response.json());
    } catch (error) {
      console.error('Failed to fetch products:', error);
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="product-list">
      {loading ? <Spinner /> : products.map(p => (
        <ProductCard key={p.id} product={p} onClick={() => onProductSelect(p)} />
      ))}
    </div>
  );
};

// 2. Custom Hooks
const useProductFetch = (productId: string) => {
  const [product, setProduct] = useState<Product | null>(null);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    fetch(`/api/products/${productId}`)
      .then(res => res.json())
      .then(setProduct)
      .catch(err => setError(err.message));
  }, [productId]);

  return { product, error };
};

// 3. API Service Layer
class ProductAPI {
  static async getAll(): Promise<Product[]> {
    const response = await fetch('/api/products');
    if (!response.ok) throw new Error('Failed to fetch products');
    return response.json();
  }

  static async getById(id: string): Promise<Product> {
    const response = await fetch(`/api/products/${id}`);
    if (!response.ok) throw new Error('Product not found');
    return response.json();
  }
}
```

### Database & MySQL

```sql
-- 1. Table Creation with Proper Constraints
CREATE TABLE products (
  id INT PRIMARY KEY AUTO_INCREMENT,
  name VARCHAR(255) NOT NULL,
  description TEXT,
  price DECIMAL(10, 2) NOT NULL,
  stock INT DEFAULT 0,
  category_id INT NOT NULL,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  FOREIGN KEY (category_id) REFERENCES categories(id),
  INDEX idx_category_id (category_id),
  INDEX idx_name (name)
);

-- 2. Query Optimization
SELECT p.*, c.name as category_name
FROM products p
JOIN categories c ON p.category_id = c.id
WHERE p.category_id = ? AND p.stock > 0
LIMIT ? OFFSET ?;

-- 3. Index Strategy
-- Add indexes on:
-- - Foreign keys (for JOINs)
-- - Columns used in WHERE clauses
-- - Columns used in ORDER BY
-- - Columns used in GROUP BY
```

---

## Feature Implementation Guidelines

### 1. User Registration & Authentication

- Use bcrypt for password hashing (cost factor: 10)
- Generate JWT tokens with expiration (e.g., 24 hours)
- Refresh token mechanism for long-lived sessions
- Validate email format and uniqueness
- Implement password strength requirements

### 2. Product Management

- Bulk upload via CSV (validate before insertion)
- Pagination for large datasets (default: 20 items/page)
- Filtering by category, price range, availability
- Full-text search on product name and description
- Stock management and alerts

### 3. Shopping Cart

- Persist cart in database (not just browser)
- Update quantities without item duplication
- Real-time stock availability check
- Calculate subtotal, taxes, and total
- Cart abandonment notifications (optional)

### 4. Discount System

- Support percentage and fixed amount discounts
- Time-based validity (valid_from, valid_to)
- Usage limits (max uses, per-user limit)
- Automatic validation during checkout
- Detailed audit log for discount application

### 5. Order Management

- Atomic transaction for order creation
- Order status workflow: pending → processing → shipped → delivered
- Invoice generation
- Email notifications on status changes
- Order history and search functionality

### 6. Admin Panel

- Dashboard with KPIs (total sales, orders, active users)
- User management (view, edit, deactivate)
- Product management (CRUD, bulk operations)
- Order management (view, update status, refunds)
- Discount management
- Report generation

---

## Development Workflow

### Git Conventions

1. **Branch Naming**:
   - Feature: `feature/description-of-feature`
   - Bug: `bugfix/description-of-bug`
   - Hotfix: `hotfix/urgent-fix`

2. **Commit Messages**:
   ```
   [TYPE] Brief description
   
   Optional detailed explanation:
   - Point 1
   - Point 2
   
   Closes #ISSUE_NUMBER
   ```
   Types: feat, fix, refactor, docs, test, chore

3. **Pull Request Requirements**:
   - Clear description of changes
   - Reference related issues
   - Code review approval required
   - All tests passing

### Testing Strategy

1. **Unit Tests**:
   - Test individual functions and services
   - Use Jest or Mocha + Chai
   - Aim for 80%+ code coverage

2. **Integration Tests**:
   - Test service interactions
   - Mock external APIs
   - Test database operations

3. **E2E Tests**:
   - Test complete user workflows
   - Use Playwright or Cypress for frontend
   - Test critical paths: registration, purchase, admin operations

### Local Development

```bash
# Backend Setup
cd backend
npm install
cp .env.example .env
# Configure database credentials in .env
npm run dev

# Frontend Setup
cd frontend
npm install
npm start

# Database
# Use MySQL Workbench or command line to initialize database
mysql -u root -p < schema.sql
```

---

## Common Development Tasks

### Adding a New Feature

1. Create a new branch: `git checkout -b feature/new-feature`
2. Create controller/component for the feature
3. Implement service/business logic
4. Add database schema changes (migrations if applicable)
5. Write unit tests
6. Update documentation
7. Submit PR for review

### Debugging Tips

- Use `console.log()` strategically or use a debugger
- Check `.env` file for correct configuration
- Verify database connectivity
- Use browser DevTools for frontend debugging
- Check network tab for API request/response issues
- Review error logs for stack traces

### Performance Optimization

- Implement database query caching
- Use pagination for large datasets
- Optimize images and assets
- Enable gzip compression
- Use CDN for static assets
- Implement lazy loading in React components

---

## Documentation Requirements

### Code Documentation

- Comment complex logic, not obvious code
- Document public API endpoints with request/response examples
- Keep README updated with setup instructions
- Document environment variables in `.env.example`

### API Documentation

```markdown
### GET /api/products

Retrieve all products with pagination

**Query Parameters**:
- `page` (number, default: 1) - Page number
- `limit` (number, default: 20) - Items per page
- `category` (string) - Filter by category

**Response**:
```json
{
  "success": true,
  "data": [{ "id": 1, "name": "Product", "price": 29.99 }],
  "pagination": { "page": 1, "total": 100 }
}
```
```

---

## Troubleshooting & FAQs

### Q: "Cannot connect to database"
A: Check MySQL service is running, verify credentials in `.env`, ensure database exists

### Q: "JWT token expired"
A: Implement refresh token endpoint, update token in localStorage

### Q: "CORS error when calling API"
A: Update CORS middleware in Express with correct origin URLs

### Q: "Performance degradation with large product lists"
A: Implement pagination, add database indexes, use caching

---

## Resources & References

- **Express.js**: https://expressjs.com/
- **React TypeScript**: https://react-typescript-cheatsheet.netlify.app/
- **MySQL**: https://dev.mysql.com/doc/
- **JWT**: https://jwt.io/
- **bcrypt**: https://www.npmjs.com/package/bcrypt
- **Postman API**: For API testing and documentation

---

## Project Goals & Milestones

1. **Phase 1**: Core e-commerce functionality (products, cart, orders)
2. **Phase 2**: Admin panel and user management
3. **Phase 3**: Discount system and promotions
4. **Phase 4**: Advanced features (recommendations, analytics)
5. **Phase 5**: Performance optimization and scaling

---

## Contact & Support

For questions or clarifications about this project:
- Check the memory-bank folder for architectural decisions
- Review existing code for patterns and conventions
- Consult the team documentation in `/docs` (if available)

---

**Last Updated**: December 28, 2025
**Version**: 1.0
**Maintained by**: Development Team
